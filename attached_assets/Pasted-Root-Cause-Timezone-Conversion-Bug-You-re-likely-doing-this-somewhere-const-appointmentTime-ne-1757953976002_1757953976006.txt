Root Cause: Timezone Conversion Bug

You're likely doing this somewhere:

const appointmentTime = new Date(scheduledTime); 
const timeSlot = format(appointmentTime, 'h:mm A');

ðŸ”¥ Problem:

new Date(scheduledTime) auto-converts from UTC to local time.

If your DB stores times in UTC, and you display in local time, this introduces a 1-hour shift in many regions.

ðŸ“Œ Example:

scheduled_at = '2025-09-16 14:30:00' UTC

Local time = 2:30 PM UTC â†’ **2:00 PM** local if your timezone is UTC+5:30 (like India)

So 2:00 PM appears incorrectly blocked, because the time slot logic sees it as used.

âœ… Fix: Use UTC-aware Date Parsing

Use a proper date parser like dayjs or date-fns-tz to interpret time without shifting timezones.

ðŸ‘‰ With dayjs:
const dayjs = require('dayjs');
const utc = require('dayjs/plugin/utc');
const timezone = require('dayjs/plugin/timezone');

dayjs.extend(utc);
dayjs.extend(timezone);

// Keep the DB time in UTC and convert to your expected display time zone
const userTimeZone = 'Asia/Karachi'; // Change as needed

const appointmentTime = dayjs.utc(scheduledTime).tz(userTimeZone);
const timeSlot = appointmentTime.format('h:mm A');


Now, 14:30 UTC becomes 7:30 PM in Asia/Karachi, and won't falsely block 2:00 PM.

âœ… Fix Time Slot Mapping Logic
Before (buggy):
const timeSlot = format(new Date(row.scheduled_at), 'h:mm A');

After (corrected):
const timeSlot = dayjs.utc(row.scheduled_at).tz('Your/Timezone').format('h:mm A');


Replace 'Your/Timezone' with whatever your users actually expect (or let them set it).

âœ… Final Fix Plan

Inspect all usage of new Date() on scheduled_at values

Replace with dayjs.utc(...).tz(...).format(...) or equivalent

Ensure duration is only blocking the current slot, not extra ones

Verify with debug logs like:

console.log('[DEBUG] Slot generated:', timeSlot, 'from raw:', row.scheduled_at);


Test with appointments at edge cases like:

2:00 PM (should be green)

2:30 PM (should be grey)

âœ… Bonus: Optional Duration Logic

If you want to block multiple slots based on duration, you could do:

const duration = row.duration || 30;
const start = dayjs.utc(row.scheduled_at).tz('Your/Timezone');
const end = start.add(duration, 'minute');

// Block all slots between start and end
for (let slot of timeSlots) {
  const slotTime = dayjs.tz(slot, 'h:mm A', 'Your/Timezone');
  if (slotTime.isAfter(start.subtract(1, 'minute')) && slotTime.isBefore(end)) {
    blockedSlots.push(slot);
  }
}

âœ… Final Thought

You're correctly analyzing data. Now just adjust how you're parsing and comparing time â€” make sure it's timezone-safe and exact, and the incorrect greying will stop.